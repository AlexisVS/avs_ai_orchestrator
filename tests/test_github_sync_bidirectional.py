#!/usr/bin/env python3
"""
Tests TDD pour Mode PULL - Synchronisation Bidirectionnelle GitHub
Tests pour lecture des issues existantes et sync avec Project Board
"""

import pytest
import asyncio
import json
from unittest.mock import Mock, AsyncMock, patch, MagicMock
from pathlib import Path
from datetime import datetime

import sys
sys.path.insert(0, str(Path(__file__).parent.parent))

from src.orchestrator.agents.github_sync_agent import GitHubSyncAgent


class TestGitHubIssueFetching:
    """Tests TDD pour lecture des issues GitHub existantes"""
    
    @pytest.mark.asyncio
    async def test_fetch_github_issues_all(self):
        """Test recuperation de toutes les issues ouvertes"""
        # GIVEN un agent GitHub Sync
        agent = GitHubSyncAgent({})
        
        # WHEN on recupere les issues
        with patch.object(agent, '_run_gh_command') as mock_gh:
            mock_gh.return_value = json.dumps([
                {
                    "number": 1,
                    "title": "[EPIC] Phase 1: Architecture",
                    "state": "OPEN",
                    "labels": [{"name": "enhancement"}],
                    "body": "Implementation of architecture",
                    "assignees": [],
                    "milestone": None
                },
                {
                    "number": 2,
                    "title": "[FEATURE] Agent Discovery",
                    "state": "OPEN",
                    "labels": [{"name": "feature"}],
                    "body": "Implement agent discovery service",
                    "assignees": ["user1"],
                    "milestone": {"title": "v1.0"}
                }
            ])
            
            issues = await agent.fetch_github_issues()
        
        # THEN on doit obtenir les issues
        assert len(issues) == 2
        assert issues[0]["number"] == 1
        assert issues[0]["title"] == "[EPIC] Phase 1: Architecture"
        assert issues[1]["number"] == 2
        assert issues[1]["assignees"] == ["user1"]
    
    @pytest.mark.asyncio
    async def test_fetch_github_issues_filtered(self):
        """Test recuperation des issues filtrees (non auto-generees)"""
        # GIVEN un agent
        agent = GitHubSyncAgent({})
        
        # WHEN on recupere les issues non auto-generees
        with patch.object(agent, '_run_gh_command') as mock_gh:
            mock_gh.return_value = json.dumps([
                {
                    "number": 1,
                    "title": "Manual issue",
                    "labels": [{"name": "bug"}],
                    "body": "User reported bug"
                },
                {
                    "number": 2,
                    "title": "Auto-Fix: Generated issue",
                    "labels": [{"name": "auto-generated"}],
                    "body": "Auto-generated by orchestrator"
                }
            ])
            
            issues = await agent.fetch_github_issues(exclude_auto_generated=True)
        
        # THEN seules les issues manuelles doivent etre retournees
        assert len(issues) == 1
        assert issues[0]["number"] == 1
        assert issues[0]["title"] == "Manual issue"
    
    @pytest.mark.asyncio
    async def test_parse_issue_to_opportunity(self):
        """Test conversion d'une issue GitHub en opportunite"""
        # GIVEN un agent et une issue
        agent = GitHubSyncAgent({})
        issue = {
            "number": 5,
            "title": "[FEATURE] Real-Time Monitoring",
            "labels": [{"name": "enhancement"}, {"name": "monitoring"}],
            "body": "Add real-time monitoring capabilities",
            "assignees": [],
            "milestone": {"title": "v2.0"}
        }
        
        # WHEN on parse l'issue
        opportunity = agent.parse_issue_to_opportunity(issue)
        
        # THEN l'opportunite doit etre correctement formee
        assert opportunity["type"] == "feature"
        assert opportunity["priority"] == "medium"
        assert opportunity["source"] == "github_issue"
        assert opportunity["issue_number"] == 5
        assert opportunity["title"] == "[FEATURE] Real-Time Monitoring"
        assert opportunity["description"] == "Add real-time monitoring capabilities"
        assert opportunity["milestone"] == "v2.0"
    
    @pytest.mark.asyncio
    async def test_parse_issue_priority_detection(self):
        """Test detection de priorite selon les labels"""
        # GIVEN un agent
        agent = GitHubSyncAgent({})
        
        # Test haute priorite
        high_priority_issue = {
            "number": 1,
            "title": "Critical Bug",
            "labels": [{"name": "bug"}, {"name": "critical"}],
            "body": "Critical issue"
        }
        
        opp_high = agent.parse_issue_to_opportunity(high_priority_issue)
        assert opp_high["priority"] == "high"
        
        # Test priorite moyenne
        medium_priority_issue = {
            "number": 2,
            "title": "Enhancement",
            "labels": [{"name": "enhancement"}],
            "body": "Nice to have"
        }
        
        opp_medium = agent.parse_issue_to_opportunity(medium_priority_issue)
        assert opp_medium["priority"] == "medium"
        
        # Test basse priorite
        low_priority_issue = {
            "number": 3,
            "title": "Documentation",
            "labels": [{"name": "documentation"}],
            "body": "Update docs"
        }
        
        opp_low = agent.parse_issue_to_opportunity(low_priority_issue)
        assert opp_low["priority"] == "low"
    
    @pytest.mark.asyncio
    async def test_avoid_duplicate_processing(self):
        """Test eviter de traiter deux fois la meme issue"""
        # GIVEN un agent avec une issue deja traitee
        agent = GitHubSyncAgent({})
        agent.processed_issues = {123}  # Issue deja traitee
        
        # WHEN on verifie si l'issue doit etre traitee
        should_process_new = agent.should_process_issue(456)
        should_process_old = agent.should_process_issue(123)
        
        # THEN
        assert should_process_new is True
        assert should_process_old is False
        
        # AND apres traitement, marquer comme traitee
        agent.mark_issue_processed(456)
        assert 456 in agent.processed_issues


class TestGitHubProjectBoardSync:
    """Tests TDD pour synchronisation avec GitHub Project Board"""
    
    @pytest.mark.asyncio
    async def test_fetch_project_cards(self):
        """Test recuperation des cartes du Project Board"""
        # GIVEN un agent avec project configure
        agent = GitHubSyncAgent({"github": {"project_id": "42"}})
        
        # WHEN on recupere les cartes Todo
        with patch.object(agent, '_run_gh_command') as mock_gh:
            mock_gh.return_value = json.dumps({
                "items": [
                    {
                        "id": "card1",
                        "content": {"number": 10, "title": "Task 1"},
                        "status": "Todo",
                        "priority": 1
                    },
                    {
                        "id": "card2",
                        "content": {"number": 11, "title": "Task 2"},
                        "status": "Todo",
                        "priority": 2
                    }
                ]
            })
            
            cards = await agent.fetch_project_cards(status="Todo")
        
        # THEN on doit obtenir les cartes dans l'ordre
        assert len(cards) == 2
        assert cards[0]["content"]["number"] == 10
        assert cards[1]["content"]["number"] == 11
        assert cards[0]["priority"] == 1
    
    @pytest.mark.asyncio
    async def test_sync_with_project_board(self):
        """Test synchronisation complete avec Project Board"""
        # GIVEN un agent
        agent = GitHubSyncAgent({})
        
        # WHEN on synchronise avec le board
        with patch.object(agent, 'fetch_project_cards') as mock_fetch_cards:
            with patch.object(agent, 'fetch_github_issues') as mock_fetch_issues:
                
                # Mock les appels separes pour chaque statut
                mock_fetch_cards.side_effect = [
                    # Premier appel: Todo cards
                    [{"content": {"number": 5}, "status": "Todo"}],
                    # Deuxieme appel: In Progress cards
                    [{"content": {"number": 6}, "status": "In Progress"}]
                ]
                
                mock_fetch_issues.return_value = [
                    {"number": 5, "title": "Issue 5", "labels": []},
                    {"number": 6, "title": "Issue 6", "labels": []}
                ]
                
                sync_result = await agent.sync_with_project_board()
        
        # THEN la synchronisation doit reussir
        assert sync_result["synced"] is True
        assert sync_result["todo_count"] == 1
        assert sync_result["in_progress_count"] == 1
        assert len(sync_result["opportunities"]) >= 1
    
    @pytest.mark.asyncio
    async def test_move_card_between_columns(self):
        """Test deplacement de carte entre colonnes du board"""
        # GIVEN un agent et une carte
        agent = GitHubSyncAgent({"github": {"project_id": "42"}})
        
        # WHEN on deplace une carte
        with patch.object(agent, '_run_gh_command') as mock_gh:
            mock_gh.return_value = "Card moved"
            
            result = await agent.move_project_card("card123", "In Progress")
        
        # THEN le deplacement doit reussir
        assert result is True
        
        # AND la commande gh doit etre appelee correctement
        mock_gh.assert_called_once()
        call_args = mock_gh.call_args[0][0]
        assert "project" in call_args
        assert "item-edit" in call_args
    
    @pytest.mark.asyncio
    async def test_prioritize_by_project_order(self):
        """Test priorisation selon l'ordre dans le Project Board"""
        # GIVEN un agent et des cartes ordonnees
        agent = GitHubSyncAgent({})
        
        cards = [
            {"content": {"number": 3}, "priority": 1, "status": "Todo"},
            {"content": {"number": 1}, "priority": 2, "status": "Todo"},
            {"content": {"number": 2}, "priority": 3, "status": "Todo"}
        ]
        
        # WHEN on priorise les cartes
        prioritized = agent.prioritize_cards(cards)
        
        # THEN l'ordre doit etre respecte
        assert prioritized[0]["content"]["number"] == 3  # Priorite 1
        assert prioritized[1]["content"]["number"] == 1  # Priorite 2
        assert prioritized[2]["content"]["number"] == 2  # Priorite 3


class TestBidirectionalWorkflow:
    """Tests TDD pour workflow bidirectionnel complet"""
    
    @pytest.mark.asyncio
    async def test_pull_mode_workflow_complete(self):
        """Test workflow complet en mode PULL"""
        # GIVEN un agent configure
        agent = GitHubSyncAgent({
            "github": {"owner": "test", "repo": "test", "project_id": "42"},
            "pull_mode_enabled": True
        })
        
        # WHEN on execute le workflow PULL
        with patch.object(agent, 'sync_with_project_board') as mock_sync:
            with patch.object(agent, 'fetch_github_issues') as mock_fetch_issues:
                
                # Mock sync_with_project_board result
                mock_sync.return_value = {
                    "synced": True,
                    "todo_count": 1,
                    "in_progress_count": 0,
                    "opportunities": [
                        {
                            "type": "feature",
                            "priority": "high",
                            "issue_number": 1
                        }
                    ],
                    "total_issues": 1
                }
                
                # Mock issues pour can_auto_process_issue check
                mock_fetch_issues.return_value = [
                    {"number": 1, "title": "Manual Task", "labels": [], "assignees": []}
                ]
                
                result = await agent.execute_pull_workflow()
        
        # THEN le workflow doit identifier les taches
        assert result["issues_fetched"] == 1
        assert result["cards_synced"] == 1
        assert len(result["opportunities_created"]) == 1
        assert result["opportunities_created"][0]["issue_number"] == 1
    
    @pytest.mark.asyncio
    async def test_prevent_infinite_loop(self):
        """Test prevention des boucles infinies"""
        # GIVEN un agent avec detection de boucle
        agent = GitHubSyncAgent({})
        
        # Simuler une issue auto-generee
        auto_generated_issue = {
            "number": 99,
            "title": "Auto-Fix: Generated",
            "labels": [{"name": "auto-generated"}],
            "body": "Auto-generated by orchestrator"
        }
        
        # WHEN on verifie si on doit traiter cette issue
        should_process = agent.should_process_auto_generated_issue(auto_generated_issue)
        
        # THEN on ne doit PAS la traiter (eviter boucle)
        assert should_process is False
        
        # BUT une issue manuelle doit etre traitee
        manual_issue = {
            "number": 100,
            "title": "User Request",
            "labels": [{"name": "bug"}],
            "body": "Manual issue"
        }
        
        should_process_manual = agent.should_process_auto_generated_issue(manual_issue)
        assert should_process_manual is True
    
    @pytest.mark.asyncio
    async def test_respect_user_assignments(self):
        """Test respect des assignations utilisateur"""
        # GIVEN un agent et des issues assignees
        agent = GitHubSyncAgent({})
        
        # Issue assignee a un utilisateur
        assigned_issue = {
            "number": 1,
            "title": "Assigned Task",
            "assignees": ["user1", "user2"],
            "labels": []
        }
        
        # Issue non assignee
        unassigned_issue = {
            "number": 2,
            "title": "Unassigned Task",
            "assignees": [],
            "labels": []
        }
        
        # WHEN on verifie qui peut traiter
        can_process_assigned = agent.can_auto_process_issue(assigned_issue)
        can_process_unassigned = agent.can_auto_process_issue(unassigned_issue)
        
        # THEN respecter les assignations
        assert can_process_assigned is False  # Ne pas toucher aux issues assignees
        assert can_process_unassigned is True  # OK pour traiter les non-assignees
    
    @pytest.mark.asyncio
    async def test_sync_status_with_pull_mode(self):
        """Test statut de synchronisation avec mode PULL"""
        # GIVEN un agent avec mode PULL
        agent = GitHubSyncAgent({"pull_mode_enabled": True})
        agent.processed_issues = {1, 2, 3}
        agent.pending_sync_cards = ["card1", "card2"]
        
        # WHEN on obtient le statut
        status = await agent.get_sync_status()
        
        # THEN le statut doit inclure les infos PULL
        assert status["sync_enabled"] is True
        assert status["pull_mode_enabled"] is True
        assert status["processed_issues_count"] == 3
        assert status["pending_sync_cards"] == 2
    
    @pytest.mark.asyncio
    async def test_integration_with_orchestrator(self):
        """Test integration du mode PULL avec l'orchestrateur"""
        # GIVEN un orchestrateur mocké avec GitHub Sync en mode PULL
        from unittest.mock import Mock, AsyncMock
        
        orchestrator = Mock()
        orchestrator.config = {"pull_mode_enabled": True}
        orchestrator.github_sync = Mock()
        orchestrator._detect_improvement_opportunities = AsyncMock(return_value=[])
        
        # Mock les methodes GitHub
        with patch.object(orchestrator.github_sync, 'execute_pull_workflow') as mock_pull:
            mock_pull.return_value = {
                "opportunities_created": [
                    {"type": "bug_fix", "priority": "high", "issue_number": 10}
                ]
            }
            
            # WHEN l'orchestrateur detecte les opportunites
            # Il devrait inclure les issues GitHub
            opportunities = await orchestrator._detect_improvement_opportunities()
            
            # Note: Cette partie necessite modification de _detect_improvement_opportunities
            # pour appeler github_sync.execute_pull_workflow()
            
            # THEN les opportunites GitHub devraient etre incluses
            # (Ce test echouera initialement - TDD Phase RED)
            assert len(opportunities) >= 0  # Placeholder pour l'instant


class TestGitHubSyncAgentMethods:
    """Tests pour les nouvelles methodes du GitHubSyncAgent"""
    
    def test_github_sync_agent_has_pull_methods(self):
        """Test que l'agent a les methodes necessaires pour le mode PULL"""
        # GIVEN un agent
        agent = GitHubSyncAgent({})
        
        # THEN il doit avoir les methodes PULL
        assert hasattr(agent, 'fetch_github_issues')
        assert hasattr(agent, 'parse_issue_to_opportunity')
        assert hasattr(agent, 'fetch_project_cards')
        assert hasattr(agent, 'sync_with_project_board')
        assert hasattr(agent, 'execute_pull_workflow')
        assert hasattr(agent, 'should_process_issue')
        assert hasattr(agent, 'mark_issue_processed')
        assert hasattr(agent, 'can_auto_process_issue')
        assert hasattr(agent, 'prioritize_cards')
        assert hasattr(agent, 'move_project_card')
        assert hasattr(agent, 'should_process_auto_generated_issue')